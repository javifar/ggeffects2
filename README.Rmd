---
output: 
  github_document:
    toc: false
    fig_width: 10.08
    fig_height: 6
vignette: >
  \usepackage[utf8]{inputenc}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  tidy.opts = list(width.cutoff = 80),
  tidy = TRUE,
  fig.path = "README-",
  fig.width = 600,
  comment = "#>",
  echo = TRUE
)
options(knitr.kable.NA = '', digits = 2, width = 80)
library(dplyr)
```

# `ggggeffects`

The goal of `ggggeffects` is to allow for a `ggplot2` syntax for the actual plotting of the data-grid provided by `ggeffects`.

I built this because I love `ggeffects`, but I wanted more control over the plotting.

Let's look at some examples:

```{r}
library(ggggeffects)
```


## Example 1: `mtcars`

Fit the model:

```{r}
fit <- lm(mpg ~ factor(cyl) + am + disp + hp, mtcars)
```

```{r}
gge <- ggpredict(fit, terms = c("cyl", "am"))

# Compare
plot(gge)

# To:
autoplot(gge) +
  geom_CI_bar() +
  geom_expected_point()
```

The default plot is better looking than the ugly `ggplot2` default, however `ggggeffects` is fully customisable, as would be expected (also not that the `am` is retained as a numeric variable):

```{r}
autoplot(gge, aes(color = factor(am), fill = after_scale(color)),
         fct_cols = vars(am)) +
  geom_CI_bar(width = .3, color = "black", position = position_dodge(0.3)) +
  geom_expected_point(size = 2, position = position_dodge(0.3)) +
  theme_bw() +
  labs(color = "am")
```

Here is an example with a continious variable on x:


```{r}
gge <- ggpredict(fit, c("disp", "hp", "am"))

autoplot(gge) +
  geom_CI_ribbon(color = NA, alpha = 0.2) +
  geom_expected_line() +
  stat_raw_data() +
  scale_color_distiller(type = "div", palette = 7, 
                        aesthetics = c("color", "fill")) +
  theme_bw()
```

Where `stat_raw_data()` adds the raw data to the plot!

We can also create partial residual plots with `stat_residualized_data()`:

```{r}
autoplot(gge) +
  geom_CI_ribbon(color = NA, alpha = 0.2) +
  geom_expected_line() +
  stat_residualized_data() +
  scale_color_distiller(type = "div", palette = 7, 
                        aesthetics = c("color", "fill")) +
  theme_bw()
```

## Example 2: MLM

Here is an example from MLM Stroop data:

```{r}
library(dplyr)

data("stroop", package = "afex")

set.seed(42)

some_stroop_data <- stroop %>%
  filter(study == 1 & acc == 1, trialnum < 60) %>%
  sample_n(1000) %>%
  mutate(
    pno = factor(pno),
    level1_cov = rnorm(n())
  ) %>%
  group_by(pno) %>%
  mutate(level2_cov = rnorm(1)) %>%
  ungroup()



# Make a model ----

m <- lme4::lmer(rt ~ condition + congruency + level1_cov + level2_cov +
                  (congruency | pno) + ( 1 | trialnum),
                data = some_stroop_data)


gge <- ggemmeans(m, c("congruency", "condition"))


p <- autoplot(gge) +
  geom_CI_bar(width = .5, color = "black", position = position_dodge(0.7)) +
  geom_expected_point(position = position_dodge(0.7), size = 3)

p +
  stat_raw_data(position = position_jitterdodge(0.1,,0.7), alpha = 0.1)
```


We also have the option to collapse across grouping variables in MLM.

```{r}
p +
  stat_raw_data(collaps.group = TRUE, 
                position = position_jitterdodge(0.1,,0.7), alpha = 0.1)
```

Or specify by name:

```{r}
p +
  stat_raw_data(collaps.group = "trialnum", 
                position = position_jitterdodge(0.1,,0.7), alpha = 0.1)
```

We can do the same for residualized data:

```{r}
p +
  stat_residualized_data(collaps.group = "pno", 
                         position = position_jitterdodge(0.1,,0.7), alpha = 0.1)
```


```{r}
gge <- ggemmeans(m, c("level2_cov [all]", "congruency", "condition"))

autoplot(gge) +
  geom_CI_ribbon(color = NA, alpha = 0.1) +
  geom_expected_line() +
  stat_residualized_data(collaps.group = "pno", alpha = 0.1)
```

